/**
\mainpage Introduction

This library is a USB stack which uses the OTG_FS module of the STM32F4 series of microcontrollers to provide device-only (no host or dual-role) functionality.
It is designed to work within a FreeRTOS framework.

When initialized, the USB stack launches one internal task, known as the stack internal task.
This task is used to handle both device-wide state changes (such as cable plugging and unplugging, and USB reset signalling) and also all traffic on IN and OUT endpoints zero.
The stack internal task is visible to the application because, in the course of handling endpoint zero traffic, application-provided callbacks may be invoked.

A simple application will, while the device is enabled into a particular setup (configuration or interface alternate setting), run one task for each nonzero endpoint.
A more complex application may have a 1:N mapping between tasks and endpoints, where one task handles multiple endpoints using the asynchronous API.
However, in no case may multiple tasks operate a single endpoint simultaneously.
In either case, the USB stack first activates the relevant endpoints then invokes an application callback notifying it that the setup has been entered.
The callback should launch all relevant tasks, along with any other application-specific setup.

When a particular setup is being exited (a configuration is being exited or an interface is being given a different alternate setting), resources must be torn down.
First, the USB stack deactivates the relevant endpoints.
This results in any operations on those endpoints failing, with \c errno set to \c ECONNRESET.
Although the task is not strictly required to terminate when this occurs, this would be the usual response, perhaps after cleaning up any allocated resources.
However, the application is required to stop operating on the endpoint, at least until a setup-entry callback is invoked notifying the application that the endpoint is again ready for use.

Once the endpoints are deactivated, the stack internal task invokes the setup-exit callback for the configuration or alternate setting.
This callback can do any application-specific teardown needed.
To prevent a condition where an endpoint is deactivated and then reactivated in a different setup without the endpoint’s task noticing (due to being busy with other work), the setup-exit callback \em must not return until it has confirmed that all application tasks are aware of the endpoint’s deactivation.

In a typical application where task lifetimes are bound to endpoint lifetimes, this is easy to accomplish.
As each task observes the \c ECONNRESET failure on its endpoint operations, it prepares to terminate; just before terminating, it gives a semaphore.
The setup-exit callback takes the same semaphore once for each endpoint-handling task, thus ensuring it only returns once all those tasks have committed to terminating.

Note that because endpoints are deactivated by the stack before the setup-exit callback is invoked, it is possible that endpoint-handling tasks may be starting to terminate before the setup-exit callback gets to work.
This sequence does mean, however, that as long as a particular task only ever blocks waiting for USB traffic, the application’s setup-exit callback need not implement a signalling system to notify the task when it needs to terminate; this can be done adequately by the task observing the endpoint failing.

\section ASYNC Asynchronous API

The asynchronous API allows multiple nonzero endpoints to be handled by a single FreeRTOS task.
This may be useful when the endpoints perform closely coupled operations which are better handled by a single task.

To use the asynchronous API, the application must first allocate a FreeRTOS event group.
The application then starts the asynchronous operations, passing the event group and a bitmask to each operation.
When an endpoint involved in an asynchronous operation needs servicing, the corresponding bitmask is set in the event group.
The application must then try to finish the operation.
Note that the application must not take the setting of the bits to mean that the operation is complete.
Some operations take multiple steps; when one step is complete, the event bits are set, but the finish function will start the next step and return with \c errno set to \c EINPROGRESS.

There are no restrictions on which bits the application uses for different operations.
The application can choose to allocate a bit per endpoint, and then try to finish operations based on which bits are set.
Alternatively, the application can specify the same bit for all endpoints and, when that bit is set, try to finish all pending operations.
Mixtures of these are possible (e.g. allocating subgroups of endpoints).
The application may also use any of the event bits not specified for endpoint operations for its own signalling.
An application may even share bits between endpoint operations and other application signalling, as long as it is prepared for the case where the bit is set by the USB stack rather than the application signalling mechanism.
In general, it is harmless to try to finish an endpoint operation that has not indicated a need for servicing (though of course it is more efficient to avoid doing this if possible).
The only rule is that, when an endpoint needs servicing, it will set its event bits once and only once; if an application fails to finish an operation that is ready to finish and then goes back to sleep, it may deadlock waiting for an endpoint that has already asked for service.

It is essential that all asynchronous operations that are started are finished by the same task.
For example, when exiting a configuration or alternate setting, the task handling the endpoints must ensure it keeps polling and finishing operations until all operations report \c ECONNRESET (or success) rather than \c EINPROGRESS.
If this is not done, the operation will remain unfinished, and any further activity on that endpoint will deadlock waiting for the operation to finish.
Because FreeRTOS mutexes are used internally, the finish function (which releases a mutex) must be called by the same task as the start function (which takes that mutex).

The asynchronous API does not allow multiple transfers to be queued for a single endpoint.
Attempting to start a second transfer before the first is finished will block until the first transfer is finished.
Because the first transfer is not considered finished until its finish function has returned, if this attempt is made from the same task that would normally run the finish function, the system will deadlock.
*/
