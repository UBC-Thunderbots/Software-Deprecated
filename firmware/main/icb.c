/**
 * \defgroup ICB Inter-Chip Bus Functions
 *
 * \brief These functions manage the inter-chip bus between microcontroller and FPGA.
 *
 * The bus is used in two different ways at different times.
 * During system boot, the ICB is used to deliver a configuration bitstream to the FPGA.
 * Once the FPGA is configured, the ICB is used to communicate with the logic in the FPGA.
 *
 * In addition to the basic SPI bus which runs between the two chips, there is also an interrupt wire, used during normal ICB operation.
 * An interrupt controller in the FPGA records and latches a set of edge-sensitive interrupts generated by different subsystems.
 * The current set of pending interrupts can be atomically read and cleared using an ordinary command over the bus.
 * Additionally, whenever the pending interrupt set is nonempty, the separate interrupt wire is driven high.
 * An internal task in this module is notified when this happens, issues the read-and-clear command, and distributes the resulting interrupt sources to their individual handlers.
 *
 * @{
 */

#include "icb.h"
#include "dma.h"
#include "pins.h"
#include "priority.h"
#include <FreeRTOS.h>
#include <assert.h>
#include <gpio.h>
#include <minmax.h>
#include <rcc.h>
#include <semphr.h>
#include <task.h>
#include <unused.h>
#include <registers/dma.h>
#include <registers/exti.h>
#include <registers/spi.h>
#include <registers/syscfg.h>

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI receive path.
 */
#define DMA_STREAM_RX 0U

/**
 * \internal
 *
 * \brief The DMA stream number for the SPI transmit path.
 */
#define DMA_STREAM_TX 3U

/**
 * \internal
 *
 * \brief The DMA channel number.
 */
#define DMA_CHANNEL 3U

/**
 * \brief A mutex protecting the bus from multiple simultaneous accesses.
 */
static SemaphoreHandle_t bus_mutex;

/**
 * \brief A semaphore used by the DMA ISRs to notify mainline code.
 */
static SemaphoreHandle_t dma_tc_sem;

/**
 * \brief A semaphore handle used by the EXTI ISR to notify the interrupt dispatcher task.
 */
static SemaphoreHandle_t irq_sem;

/**
 * \brief The semaphores to notify when ICB IRQs are asserted.
 */
static void (*irq_handlers[ICB_IRQ_COUNT])(void);

/**
 * \brief Whether any CRC errors have occurred.
 */
static bool crc_error = false;

/**
 * \brief Takes the simultaneous-access mutex.
 */
static void lock_bus(void) {
	xSemaphoreTake(bus_mutex, portMAX_DELAY);
}

/**
 * \brief Releases the simultaneous-access mutex.
 */
static void unlock_bus(void) {
	xSemaphoreGive(bus_mutex);
}

/**
 * \brief Sets the chip select line to float with a pull-up resistor.
 */
static void float_cs(void) {
	gpio_set(PIN_ICB_CS);
	gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_PU);
	gpio_set_od(PIN_ICB_CS);
}

/**
 * \brief Asserts (drives low) the chip select line.
 */
static void assert_cs(void) {
	gpio_reset(PIN_ICB_CS);
	gpio_set_pp(PIN_ICB_CS);
	gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_NONE);
}

/**
 * \brief Deasserts (drives high) the chip select line.
 */
static void deassert_cs(void) {
	gpio_set(PIN_ICB_CS);
	gpio_set_pp(PIN_ICB_CS);
	gpio_set_pupd(PIN_ICB_CS, GPIO_PUPD_NONE);
}

/**
 * \brief Delays for roughly a bit time.
 */
#define sleep_bit(void) \
	do { \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
		asm volatile("nop":::); \
	} while (0)

/**
 * \name Module initialization
 *
 * @{
 */

/**
 * \brief Initializes the ICB.
 */
void icb_init(void) {
	// Create the FreeRTOS objects.
	bus_mutex = xSemaphoreCreateMutex();
	dma_tc_sem = xSemaphoreCreateBinary();
	irq_sem = xSemaphoreCreateBinary();
	assert(bus_mutex && dma_tc_sem && irq_sem);

	// Enable clock and reset module.
	rcc_enable_reset(APB2, SPI1);

	// Enable the interrupts we will eventually use.
	// Individual causes stay masked off in the peripherals until needed, but in the NVIC the interrupts stay enabled.
	portENABLE_HW_INTERRUPT(6U, PRIO_EXCEPTION_ICB_IRQ);
	portENABLE_HW_INTERRUPT(56U, PRIO_EXCEPTION_ICB_DMA);
	portENABLE_HW_INTERRUPT(59U, PRIO_EXCEPTION_ICB_DMA);
}

/**
 * @}
 */

/**
 * \name Normal communication
 *
 * These functions are used to communicate with logic in a fully configured FPGA.
 *
 * @{
 */

/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with no parameters.
 *
 * \param[in] command the command to request
 */
static void icb_send_nullary(icb_command_t command) {
	// Prevent any simultaneous access to the bus.
	lock_bus();

	// Enable the SPI module for PIO.
	SPI_CR1_t cr1 = {
		.CPHA = 0, // Capture on first clock transition, drive new data on second.
		.CPOL = 0, // Clock idles low.
		.MSTR = 1, // Master mode.
		.BR = 0, // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
		.SPE = 1, // SPI module now enabled.
		.LSBFIRST = 0, // Most significant bit is sent first.
		.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
		.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
		.RXONLY = 0, // Transmit and receive.
		.DFF = 0, // Frames are 8 bits wide.
		.CRCNEXT = 1, // The CRC will immediately accompany the command byte.
		.CRCEN = 1, // CRC calculation enabled for this transaction.
		.BIDIMODE = 0, // 2-line bidirectional communication used.
	};
	SPI1.CR1 = cr1;

	// Allow the clock pin to settle.
	sleep_bit();

	// Assert chip select.
	assert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Send the command byte.
	SPI1.DR = command;

	// Wait for completion.
	while (!SPI1.SR.TXE);
	while (SPI1.SR.BSY);

	// Wait for final required interval.
	sleep_bit();

	// Deassert chip select.
	deassert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Disable the SPI module.
	cr1.SPE = 0;
	cr1.CRCEN = 0;
	SPI1.CR1 = cr1;

	// Done.
	unlock_bus();
}

/**
 * \internal
 *
 * \brief Executes a microcontroller-to-FPGA ICB transaction with a parameter block.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
static void icb_send_param(icb_command_t command, const void *data, size_t length) {
	// Sanity check.
	assert(dma_check(data, length));

	// Prevent any simultaneous access to the bus.
	lock_bus();

	// Clear old DMA interrupts.
	{
		_Static_assert(DMA_STREAM_TX == 3U, "LIFCR needs rewriting to the proper stream number!");
		DMA_LIFCR_t lifcr = {
			.CFEIF3 = 1U, // Clear FIFO error interrupt flag.
			.CDMEIF3 = 1U, // Clear direct mode error interrupt flag.
			.CTEIF3 = 1U, // Clear transfer error interrupt flag.
			.CHTIF3 = 1U, // Clear half transfer interrupt flag.
			.CTCIF3 = 1U, // Clear transfer complete interrupt flag.
		};
		DMA2.LIFCR = lifcr;
	}

	// Set up the transmit DMA channel to send the parameter data block.
	{
		DMA_SxFCR_t fcr = {
			.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
			.DMDIS = 1, // Use the FIFO.
		};
		DMA2.streams[DMA_STREAM_TX].FCR = fcr;
		DMA2.streams[DMA_STREAM_TX].PAR = &SPI1.DR;
		DMA2.streams[DMA_STREAM_TX].M0AR = (void *) data; // Casting away constness is safe because this DMA stream will operate in memory-to-peripheral mode.
		DMA2.streams[DMA_STREAM_TX].NDTR = length;
		DMA_SxCR_t scr = {
			.EN = 1, // Enable DMA engine.
			.DMEIE = 1, // Enable direct mode error interrupt.
			.TEIE = 1, // Enable transfer error interrupt.
			.TCIE = 1, // Enable transfer complete interrupt.
			.PFCTRL = 0, // DMA engine controls data length.
			.DIR = DMA_DIR_M2P,
			.CIRC = 0, // No circular buffer mode.
			.PINC = 0, // Do not increment peripheral address.
			.MINC = 1, // Increment memory address.
			.PSIZE = DMA_DSIZE_BYTE,
			.MSIZE = DMA_DSIZE_BYTE,
			.PINCOS = 0, // No special peripheral address increment mode.
			.PL = 1, // Priority 1 (medium).
			.DBM = 0, // No double-buffer mode.
			.CT = 0, // Use memory pointer zero.
			.PBURST = DMA_BURST_SINGLE,
			.MBURST = DMA_BURST_SINGLE,
			.CHSEL = DMA_CHANNEL,
		};
		DMA2.streams[DMA_STREAM_TX].CR = scr;
	}

	// Enable the SPI module for PIO.
	SPI_CR1_t cr1 = {
		.CPHA = 0, // Capture on first clock transition, drive new data on second.
		.CPOL = 0, // Clock idles low.
		.MSTR = 1, // Master mode.
		.BR = 0, // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
		.SPE = 1, // SPI module now enabled.
		.LSBFIRST = 0, // Most significant bit is sent first.
		.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
		.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
		.RXONLY = 0, // Transmit and receive.
		.DFF = 0, // Frames are 8 bits wide.
		.CRCNEXT = 0, // Do not transmit a CRC now.
		.CRCEN = 1, // CRC calculation enabled for this transaction.
		.BIDIMODE = 0, // 2-line bidirectional communication used.
	};
	SPI1.CR1 = cr1;

	// Allow the clock pin to settle.
	sleep_bit();

	// Assert chip select.
	assert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Send the command byte.
	SPI1.DR = command;

	// Enable transmit DMA, which will take over with the parameter bytes once the command byte is done.
	SPI_CR2_t cr2 = {
		.TXDMAEN = 1, // Transmit DMA enabled.
	};
	SPI1.CR2 = cr2;

	// Wait for DMA transfer complete.
	xSemaphoreTake(dma_tc_sem, portMAX_DELAY);

	// The SPI module sends a CRC automatically and the end of a DMA transfer, when operating in DMA mode.
	// There is no need to set CRCNEXT.

	// Wait for completion.
	while (!SPI1.SR.TXE);
	while (SPI1.SR.BSY);

	// Wait for final required interval.
	sleep_bit();

	// Deassert chip select.
	deassert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Disable transmit DMA.
	cr2.TXDMAEN = 0;
	SPI1.CR2 = cr2;

	// Disable the SPI module.
	cr1.SPE = 0;
	cr1.CRCEN = 0;
	SPI1.CR1 = cr1;

	// Done.
	unlock_bus();
}

/**
 * \brief Executes a microcontroller-to-FPGA ICB transaction.
 *
 * \param[in] command the command to request
 * \param[in] data the data block to send after the command byte as a parameter
 * \param[in] length the number of bytes in the data block to send
 */
void icb_send(icb_command_t command, const void *data, size_t length) {
	if (length) {
		icb_send_param(command, data, length);
	} else {
		icb_send_nullary(command);
	}
}

/**
 * \brief Executes an FPGA-to-microcontroller ICB transaction.
 *
 * \param[in] command the command to request
 * \param[out] buffer the buffer into which to receive data
 * \param[in] length the number of bytes to receive
 */
void icb_receive(icb_command_t command, void *buffer, size_t length) {
	// Sanity check.
	assert(length);
	assert(dma_check(buffer, length));

	// Prevent any simultaneous access to the bus.
	lock_bus();

	// Enable the SPI module for PIO.
	SPI_CR1_t cr1 = {
		.CPHA = 0, // Capture on first clock transition, drive new data on second.
		.CPOL = 0, // Clock idles low.
		.MSTR = 1, // Master mode.
		.BR = 0, // Transmission speed is 84 MHz (APB2) ÷ 2 = 42 MHz.
		.SPE = 1, // SPI module now enabled.
		.LSBFIRST = 0, // Most significant bit is sent first.
		.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
		.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
		.RXONLY = 0, // Transmit and receive.
		.DFF = 0, // Frames are 8 bits wide.
		.CRCNEXT = 0, // We will not transmit a CRC with the command byte; instead, wait until the end of transaction and DMA will trigger it.
		.CRCEN = 1, // CRC calculation enabled for this transaction.
		.BIDIMODE = 0, // 2-line bidirectional communication used.
	};
	SPI1.CR1 = cr1;

	// Allow the clock pin to settle.
	sleep_bit();

	// Assert chip select.
	assert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Send the command byte and its CRC.
	SPI1.DR = command;

	// Clear old DMA interrupts.
	{
		_Static_assert(DMA_STREAM_RX == 0U, "LIFCR needs rewriting to the proper stream number!");
		_Static_assert(DMA_STREAM_TX == 3U, "LIFCR needs rewriting to the proper stream number!");
		DMA_LIFCR_t lifcr = {
			.CFEIF0 = 1U, // Clear FIFO error interrupt flag.
			.CDMEIF0 = 1U, // Clear direct mode error interrupt flag.
			.CTEIF0 = 1U, // Clear transfer error interrupt flag.
			.CHTIF0 = 1U, // Clear half transfer interrupt flag.
			.CTCIF0 = 1U, // Clear transfer complete interrupt flag.
			.CFEIF3 = 1U, // Clear FIFO error interrupt flag.
			.CDMEIF3 = 1U, // Clear direct mode error interrupt flag.
			.CTEIF3 = 1U, // Clear transfer error interrupt flag.
			.CHTIF3 = 1U, // Clear half transfer interrupt flag.
			.CTCIF3 = 1U, // Clear transfer complete interrupt flag.
		};
		DMA2.LIFCR = lifcr;
	}

	// Set up the transmit DMA channel to send a string of zeroes.
	{
		static const uint8_t ZERO = 0U;
		DMA_SxFCR_t fcr = {
			.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
			.DMDIS = 1, // Use the FIFO.
		};
		DMA2.streams[DMA_STREAM_TX].FCR = fcr;
		DMA2.streams[DMA_STREAM_TX].PAR = &SPI1.DR;
		DMA2.streams[DMA_STREAM_TX].M0AR = (void*) &ZERO; // Casting away constness is safe because this DMA stream will operate in memory-to-peripheral mode.
		DMA2.streams[DMA_STREAM_TX].NDTR = length;
		DMA_SxCR_t scr = {
			.EN = 1, // Enable DMA engine.
			.DMEIE = 1, // Enable direct mode error interrupt.
			.TEIE = 1, // Enable transfer error interrupt.
			.TCIE = 0, // Disable transfer complete interrupt.
			.PFCTRL = 0, // DMA engine controls data length.
			.DIR = DMA_DIR_M2P,
			.CIRC = 0, // No circular buffer mode.
			.PINC = 0, // Do not increment peripheral address.
			.MINC = 0, // Do not increment memory address.
			.PSIZE = DMA_DSIZE_BYTE,
			.MSIZE = DMA_DSIZE_BYTE,
			.PINCOS = 0, // No special peripheral address increment mode.
			.PL = 1, // Priority 1 (medium).
			.DBM = 0, // No double-buffer mode.
			.CT = 0, // Use memory pointer zero.
			.PBURST = DMA_BURST_SINGLE,
			.MBURST = DMA_BURST_SINGLE,
			.CHSEL = DMA_CHANNEL,
		};
		DMA2.streams[DMA_STREAM_TX].CR = scr;
	}

	// Set up receive DMA channel to receive the parameter data block.
	{
		DMA_SxFCR_t fcr = {
			.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
			.DMDIS = 1, // Use the FIFO.
		};
		DMA2.streams[DMA_STREAM_RX].FCR = fcr;
		DMA2.streams[DMA_STREAM_RX].PAR = &SPI1.DR;
		DMA2.streams[DMA_STREAM_RX].M0AR = buffer;
		DMA2.streams[DMA_STREAM_RX].NDTR = length;
		DMA_SxCR_t scr = {
			.EN = 1, // Enable DMA engine.
			.DMEIE = 1, // Enable direct mode error interrupt.
			.TEIE = 1, // Enable transfer error interrupt.
			.TCIE = 1, // Enable transfer complete interrupt.
			.PFCTRL = 0, // DMA engine controls data length.
			.DIR = DMA_DIR_P2M,
			.CIRC = 0, // No circular buffer mode.
			.PINC = 0, // Do not increment peripheral address.
			.MINC = 1, // Increment memory address.
			.PSIZE = DMA_DSIZE_BYTE,
			.MSIZE = DMA_DSIZE_BYTE,
			.PINCOS = 0, // No special peripheral address increment mode.
			.PL = 1, // Priority 1 (medium).
			.DBM = 0, // No double-buffer mode.
			.CT = 0, // Use memory pointer zero.
			.PBURST = DMA_BURST_SINGLE,
			.MBURST = DMA_BURST_SINGLE,
			.CHSEL = DMA_CHANNEL,
		};
		DMA2.streams[DMA_STREAM_RX].CR = scr;
	}

	// Wait for free transmit buffer after command byte.
	while (!SPI1.SR.TXE);

	// Send a blank padding byte to give the slave time to sync up its response.
	SPI1.DR = 0U;

	// Wait for completion of padding byte.
	while (!SPI1.SR.TXE);
	while (SPI1.SR.BSY);

	// Clear garbage bytes received during command and padding transmission.
	(void) SPI1.DR;
	(void) SPI1.SR;

	// Enable DMA in both directions to run the parameter block.
	SPI_CR2_t cr2 = {
		.TXDMAEN = 1, // Enable transmit DMA
		.RXDMAEN = 1, // Enable receive DMA
	};
	SPI1.CR2 = cr2;

	// Wait for DMA transfer complete (only the receive stream has it enabled).
	xSemaphoreTake(dma_tc_sem, portMAX_DELAY);

	// The SPI module receives and checks a CRC automatically at the end of a DMA transfer, when operating in DMA mode.
	// There is no need to set CRCNEXT.
	// However, it is not part of the DMAd data, so we must wait until it arrives before proceeding.
	while (!SPI1.SR.RXNE);

	// Wait for completion.
	while (!SPI1.SR.TXE);
	while (SPI1.SR.BSY);

	// Check for CRC error.
	if (SPI1.SR.CRCERR) {
		// Clear error flag.
		SPI_SR_t sr = { 0 };
		SPI1.SR = sr;

		// Record error.
		__atomic_store_n(&crc_error, true, __ATOMIC_RELAXED);
	}

	// Wait for final required interval.
	sleep_bit();

	// Deassert chip select.
	deassert_cs();

	// Allow chip select to settle.
	sleep_bit();

	// Disable DMA mode.
	cr2.TXDMAEN = 0;
	cr2.RXDMAEN = 0;
	SPI1.CR2 = cr2;

	// Disable the SPI module.
	cr1.SPE = 0;
	cr1.CRCEN = 0;
	SPI1.CR1 = cr1;

	// Done.
	unlock_bus();
}

/**
 * \brief Checks whether any CRC errors have been recorded on the ICB.
 */
bool icb_crc_error_check(void) {
	return __atomic_load_n(&crc_error, __ATOMIC_RELAXED);
}

/**
 * \brief Clears any recorded CRC errors.
 */
void icb_crc_error_clear(void) {
	__atomic_store_n(&crc_error, false, __ATOMIC_RELAXED);
}

/**
 * @}
 */

/**
 * \name ICB Interrupts
 *
 * These functions handle checking and dispatching interrupts reported from the FPGA.
 *
 * @{
 */

/**
 * \brief The ICB interrupt dispatching task.
 */
static void irq_task(void *UNUSED(param)) {
	for (;;) {
		// If the IRQ pin is low, we have nothing to do.
		while (!gpio_get_input(PIN_ICB_IRQ)) {
			xSemaphoreTake(irq_sem, portMAX_DELAY);
		}

		// Read in the IRQ line state.
		static uint8_t status[(ICB_IRQ_COUNT + 7U) / 8U];
		icb_receive(ICB_COMMAND_GET_CLEAR_IRQS, status, sizeof(status));

		// Dispatch the IRQs.
		for (unsigned int i = 0U; i < ICB_IRQ_COUNT; ++i) {
			if (status[i / 8U] & (1U << (i % 8U))) {
				__atomic_signal_fence(__ATOMIC_ACQUIRE);
				void (*isr)(void) = __atomic_load_n(&irq_handlers[i], __ATOMIC_RELAXED);
				if (isr) {
					isr();
				}
			}
		}
	}
}

/**
 * \brief Handles ICB CRC error IRQs.
 */
static void icb_crc_error_isr(void) {
	__atomic_store_n(&crc_error, true, __ATOMIC_RELAXED);
}

/**
 * \brief Initializes the interrupt-handling subsystem.
 *
 * \pre The FPGA must already be configured.
 */
void icb_irq_init(void) {
	// Map EXTI0 to PB0.
	rcc_enable(APB2, SYSCFG);
	SYSCFG_EXTICR[0U] = (SYSCFG_EXTICR[0U] & ~(0xFU << 0U)) | (0b0001 << 0U);
	rcc_disable(APB2, SYSCFG);

	// Enable rising edge interrupts on EXTI0.
	EXTI_IMR |= 1U;
	EXTI_RTSR |= 1U;

	// Set up a handler for the ICB CRC error IRQ.
	icb_irq_set_vector(ICB_IRQ_ICB_CRC, &icb_crc_error_isr);

	// Start the IRQ dispatching task.
	BaseType_t ok = xTaskCreate(&irq_task, "icb-irq", 512U, 0, PRIO_TASK_ICB_IRQ, 0);
	assert(ok == pdPASS);
}

/**
 * \brief Shuts down the interrupt-handling subsystem.
 */
void icb_irq_shutdown(void) {
	// Disable rising edge interrupts on EXTI0.
	EXTI_IMR &= ~1U;
}

/**
 * \brief Sets the function that will be invoked when a particular ICB IRQ occurs.
 *
 * \param[in] irq the interrupt bit to configure
 * \param[in] isr the function to invoke when the interrupt source occurs
 */
void icb_irq_set_vector(icb_irq_t irq, void (*isr)(void)) {
	assert(irq < ICB_IRQ_COUNT);
	__atomic_signal_fence(__ATOMIC_ACQUIRE);
	__atomic_store_n(&irq_handlers[irq], isr, __ATOMIC_RELAXED);
	__atomic_signal_fence(__ATOMIC_RELEASE);
}

/**
 * @}
 */

/**
 * \name Configuration
 *
 * These functions are used to configure the FPGA.
 *
 * @{
 */

/**
 * \brief Starts the configuration process.
 *
 * \pre The ICB must have been initialized with \ref icb_init.
 *
 * \retval ICB_CONF_CONTINUE configuration can proceed by means of \ref icb_conf_block
 * \retval ICB_CONF_INIT_B_STUCK_HIGH INIT_B failed to fall when PROGRAM_B was pulled low
 * \retval ICB_CONF_INIT_B_STUCK_LOW INIT_B failed to rise after clearing configuration memory
 * \retval ICB_CONF_DONE_STUCK_HIGH DONE failed to be low for configuration
 */
icb_conf_result_t icb_conf_start(void) {
	// Lock the bus for the entire duration of the configuration operation.
	lock_bus();

	// Float chip select, thus allowing the FPGA to drive it during configuration.
	float_cs();

	// Force the FPGA into configuration mode by pulling PROGRAM_B low.
	gpio_reset(PIN_FPGA_PROGRAM_B);

	// Enable the SPI module.
	SPI_CR1_t cr1 = {
		.CPHA = 0, // Capture on first clock transition, drive new data on second.
		.CPOL = 0, // Clock idles low.
		.MSTR = 1, // Master mode.
		.BR = 4, // Transmission speed is 84 MHz (APB2) ÷ 32 = 2.625 MHz.
		.SPE = 1, // SPI module now enabled.
		.LSBFIRST = 0, // Most significant bit is sent first.
		.SSI = 1, // Module should assume slave select is high → deasserted → no other master is using the bus.
		.SSM = 1, // Module internal slave select logic is controlled by software (SSI bit).
		.RXONLY = 0, // Transmit and receive.
		.DFF = 0, // Frames are 8 bits wide.
		.CRCNEXT = 0, // Do not transmit a CRC now.
		.CRCEN = 0, // CRC calculation disabled for this transaction.
		.BIDIMODE = 0, // 2-line bidirectional communication used.
	};
	SPI1.CR1 = cr1;

	// Wait for INIT_B to go low.
	{
		unsigned int tries = 100U / portTICK_PERIOD_MS;
		while (gpio_get_input(PIN_FPGA_INIT_B) && tries) {
			--tries;
			vTaskDelay(1U);
		}
		if (gpio_get_input(PIN_FPGA_INIT_B)) {
			unlock_bus();
			return ICB_CONF_INIT_B_STUCK_HIGH;
		}
	}

	// Release PROGRAM_B.
	gpio_set(PIN_FPGA_PROGRAM_B);

	// Wait for the FPGA to clear configuration memory, sample mode pins, and set INIT_B high.
	{
		unsigned int tries = 100U / portTICK_PERIOD_MS;
		while (!gpio_get_input(PIN_FPGA_INIT_B) && tries) {
			--tries;
			vTaskDelay(1U);
		}
		if (!gpio_get_input(PIN_FPGA_INIT_B)) {
			unlock_bus();
			return ICB_CONF_INIT_B_STUCK_LOW;
		}
	}

	// The FPGA should have brought DONE low as it started configuration.
	if (gpio_get_input(PIN_FPGA_DONE)) {
		unlock_bus();
		return ICB_CONF_DONE_STUCK_HIGH;
	}

	// The FPGA is now ready to receive blocks of bitstream.
	return ICB_CONF_OK;
}

static void icb_conf_block_impl(const void *data, size_t length) {
	// Sanity check.
	assert(dma_check(data, length));

	// Clear old DMA interrupts.
	{
		_Static_assert(DMA_STREAM_TX == 3U, "LIFCR needs rewriting to the proper stream number!");
		DMA_LIFCR_t lifcr = {
			.CFEIF3 = 1U, // Clear FIFO error interrupt flag.
			.CDMEIF3 = 1U, // Clear direct mode error interrupt flag.
			.CTEIF3 = 1U, // Clear transfer error interrupt flag.
			.CHTIF3 = 1U, // Clear half transfer interrupt flag.
			.CTCIF3 = 1U, // Clear transfer complete interrupt flag.
		};
		DMA2.LIFCR = lifcr;
	}

	// Set up the transmit DMA channel to send the bitstream block.
	{
		DMA_SxFCR_t fcr = {
			.FTH = DMA_FIFO_THRESHOLD_HALF, // Threshold.
			.DMDIS = 1, // Use the FIFO.
		};
		DMA2.streams[DMA_STREAM_TX].FCR = fcr;
		DMA2.streams[DMA_STREAM_TX].PAR = &SPI1.DR;
		DMA2.streams[DMA_STREAM_TX].M0AR = (void *) data; // Casting away constness is safe because this DMA stream will operate in memory-to-peripheral mode.
		DMA2.streams[DMA_STREAM_TX].NDTR = length;
		DMA_SxCR_t scr = {
			.EN = 1, // Enable DMA engine.
			.DMEIE = 1, // Enable direct mode error interrupt.
			.TEIE = 1, // Enable transfer error interrupt.
			.TCIE = 1, // Enable transfer complete interrupt.
			.PFCTRL = 0, // DMA engine controls data length.
			.DIR = DMA_DIR_M2P,
			.CIRC = 0, // No circular buffer mode.
			.PINC = 0, // Do not increment peripheral address.
			.MINC = 1, // Increment memory address.
			.PSIZE = DMA_DSIZE_BYTE,
			.MSIZE = DMA_DSIZE_BYTE,
			.PINCOS = 0, // No special peripheral address increment mode.
			.PL = 1, // Priority 1 (medium).
			.DBM = 0, // No double-buffer mode.
			.CT = 0, // Use memory pointer zero.
			.PBURST = DMA_BURST_SINGLE,
			.MBURST = DMA_BURST_SINGLE,
			.CHSEL = DMA_CHANNEL,
		};
		DMA2.streams[DMA_STREAM_TX].CR = scr;
	}

	// Enable transmit DMA.
	SPI_CR2_t cr2 = {
		.TXDMAEN = 1, // Transmit DMA enabled.
	};
	SPI1.CR2 = cr2;

	// Wait for DMA transfer complete.
	xSemaphoreTake(dma_tc_sem, portMAX_DELAY);

	// Wait for completion.
	while (!SPI1.SR.TXE);
	while (SPI1.SR.BSY);

	// Disable transmit DMA.
	cr2.TXDMAEN = 0;
	SPI1.CR2 = cr2;
}

/**
 * \brief Delivers a block of configuration bitstream to the FPGA.
 *
 * \pre The configuration process must have been started with \ref icb_conf_start.
 *
 * \param[in] data the block of bitstream to send, or null if no more bitstream is available
 * \param[in] length the length of the bitstream block
 */
void icb_conf_block(const void *data, size_t length) {
	const uint8_t *dptr = data;
	while (length) {
		size_t frag_length = MIN(32768U, length);
		icb_conf_block_impl(dptr, frag_length);
		length -= frag_length;
		dptr += frag_length;
	}
}

/**
 * \brief Finishes configuring the FPGA.
 *
 * \pre All bitstream blocks must have been delivered with \ref icb_conf_block.
 *
 * \retval ICB_CONF_DONE configuration is complete
 * \retval ICB_CONF_DONE_STUCK_LOW the DONE pin failed to go high, indicating a corrupted bitstream
 * \retval ICB_CONF_CRC_ERROR the INIT_B pin went low, indicating a bitstream CRC error
 */
icb_conf_result_t icb_conf_end(void) {
	// Disable the SPI module.
	SPI_CR1_t cr1 = { 0 };
	SPI1.CR1 = cr1;

	// Unlock the bus.
	unlock_bus();

	// Wait until either DONE goes high (indicating completion) or INIT_B goes low (indicating CRC error).
	unsigned int retries = 1000U / portTICK_PERIOD_MS;
	while (retries--) {
		if (!gpio_get_input(PIN_FPGA_INIT_B)) {
			return ICB_CONF_CRC_ERROR;
		}
		if (gpio_get_input(PIN_FPGA_DONE)) {
			return ICB_CONF_OK;
		}
		vTaskDelay(1U);
	}

	// DONE never went high!
	return ICB_CONF_DONE_STUCK_LOW;
}

/**
 * @}
 */

/**
 * \name ISRs
 *
 * These interrupt service routines are registered in the interrupt vector table.
 *
 * @{
 */

/**
 * \brief Handles DMA controller 2 stream 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 56.
 */
void dma2_stream0_isr(void) {
	_Static_assert(DMA_STREAM_RX == 0U, "Function needs rewriting to the proper stream number!");
	DMA_LISR_t lisr = DMA2.LISR;
	DMA_LIFCR_t lifcr = {
		.CFEIF0 = lisr.FEIF0,
		.CDMEIF0 = lisr.DMEIF0,
		.CTEIF0 = lisr.TEIF0,
		.CHTIF0 = lisr.HTIF0,
		.CTCIF0 = lisr.TCIF0,
	};
	assert(!lisr.DMEIF0 && !lisr.TEIF0);
	DMA2.LIFCR = lifcr;
	if (lisr.TCIF0) {
		BaseType_t yield = pdFALSE;
		xSemaphoreGiveFromISR(dma_tc_sem, &yield);
		if (yield) {
			portYIELD_FROM_ISR();
		}
	}
}

/**
 * \brief Handles DMA controller 2 stream 3 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 59.
 */
void dma2_stream3_isr(void) {
	_Static_assert(DMA_STREAM_TX == 3U, "Function needs rewriting to the proper stream number!");
	DMA_LISR_t lisr = DMA2.LISR;
	DMA_LIFCR_t lifcr = {
		.CFEIF3 = lisr.FEIF3,
		.CDMEIF3 = lisr.DMEIF3,
		.CTEIF3 = lisr.TEIF3,
		.CHTIF3 = lisr.HTIF3,
		.CTCIF3 = lisr.TCIF3,
	};
	assert(!lisr.DMEIF3 && !lisr.TEIF3);
	DMA2.LIFCR = lifcr;
	if (lisr.TCIF3) {
		BaseType_t yield = pdFALSE;
		xSemaphoreGiveFromISR(dma_tc_sem, &yield);
		if (yield) {
			portYIELD_FROM_ISR();
		}
	}
}

/**
 * \brief Handles external interrupt line 0 interrupts.
 *
 * This function should be registered in the interrupt vector table at position 6.
 */
void exti0_isr(void) {
	// Clear pending interrupt.
	EXTI_PR = 1U;

	// Give semaphore.
	BaseType_t yield = pdFALSE;
	xSemaphoreGiveFromISR(irq_sem, &yield);
	if (yield) {
		portYIELD_FROM_ISR();
	}
}

/**
 * @}
 */

/**
 * @}
 */

