#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

enum pin_type {
	PIN_TYPE_UNUSED = 0,
	PIN_TYPE_IN,
	PIN_TYPE_OUT0,
	PIN_TYPE_OUT1,
	PIN_TYPE_VGND
};

struct pin_info {
	char appname[32];
	enum pin_type type;
};

struct port_info {
	struct pin_info pins[8];
};

static char *strip(char *str) {
	char *p;

	/* Remove comment, if any. */
	p = strchr(str, '#');
	if (p) {
		*p = '\0';
	}

	/* Remove trailing whitespace. */
	p = str + strlen(str);
	while (p > str && isspace(p[-1])) {
		*--p = '\0';
	}

	/* Remove leading whitespace. */
	p = str;
	while (isspace(*p)) {
		++p;
	}

	return p;
}

static int split(char *line, char **appname, char **physname, char **type) {
	*appname = strtok(line, " \t");
	if (!*appname) return 0;
	*physname = strtok(0, " \t");
	if (!*physname) return 0;
	*type = strtok(0, " \t");
	if (!*type) return 0;
	if (strtok(0, " \t")) return 0;
	return 1;
}

static int extract_phys(const char *phys, unsigned int *phys_port, unsigned int *phys_pin) {
	if (strlen(phys) != 3) return 0;
	if (phys[0] != 'R') return 0;
	if (phys[1] < 'A' || phys[1] > 'E') return 0;
	*phys_port = phys[1] - 'A';
	if (phys[2] < '0' || phys[2] > '7') return 0;
	*phys_pin = phys[2] - '0';
	return 1;
}

static int extract_type(const char *typename, enum pin_type *type) {
	if (strcmp(typename, "in") == 0) { *type = PIN_TYPE_IN; return 1; }
	else if (strcmp(typename, "out0") == 0) { *type = PIN_TYPE_OUT0; return 1; }
	else if (strcmp(typename, "out1") == 0) { *type = PIN_TYPE_OUT1; return 1; }
	else if (strcmp(typename, "vgnd") == 0) { *type = PIN_TYPE_VGND; return 1; }
	else return 0;
}

int main(void) {
	unsigned int line_num = 0;
	char line[4096];
	char *stripped;
	char *appname, *physname, *typename;
	unsigned int phys_port, phys_pin, lat, tris;
	enum pin_type type;
	struct port_info ports[5];

	/* Clear the port list. */
	memset(ports, 0, sizeof(ports));

	/* Read and parse the input. */
	while (fgets(line, sizeof(line), stdin)) {
		++line_num;
		stripped = strip(line);
		if (!*stripped) {
			continue;
		}
		if (!split(stripped, &appname, &physname, &typename)) {
			fprintf(stderr, "Parse error on line %u.\n", line_num);
			return 1;
		}

		if (strlen(appname) >= 32) {
			fprintf(stderr, "Syntax error on line %u: app name must be < 32 characters.\n", line_num);
			return 1;
		}

		if (!extract_phys(physname, &phys_port, &phys_pin)) {
			fprintf(stderr, "Syntax error on line %u: phys name must be Rxy, where x in {A,B,C,D,E} and y in {0..7}.\n", line_num);
			return 1;
		}

		if (!extract_type(typename, &type)) {
			fprintf(stderr, "Syntax error on line %u: type must be one of {in, out0, out1, vgnd}.\n", line_num);
			return 1;
		}

		if (ports[phys_port].pins[phys_pin].type != PIN_TYPE_UNUSED) {
			fprintf(stderr, "Semantic error on line %u: physical pin %s already used by application pin %s.\n", line_num, physname, ports[phys_port].pins[phys_pin].appname);
			return 1;
		}

		ports[phys_port].pins[phys_pin].type = type;
		strcpy(ports[phys_port].pins[phys_pin].appname, appname);
	}

	/* Generate the header.. */
	puts("\t; asmsyntax=pic");
	puts("");
	puts("\t; This file is automatically generated. Do not edit it.");
	puts("");
	puts("\tifndef PINS_INC_INCLUDED");
	puts("#define PINS_INC_INCLUDED 1");
	puts("");

	/* Generate the port name equates. */
	for (phys_port = 0; phys_port < 5; ++phys_port) {
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			appname = ports[phys_port].pins[phys_pin].appname;
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_OUT0:
				case PIN_TYPE_OUT1:
					printf("PORT_%s equ PORT%c\n", appname, (char) (phys_port + 'A'));
					printf("TRIS_%s equ TRIS%c\n", appname, (char) (phys_port + 'A'));
					printf("LAT_%s  equ LAT%c\n",  appname, (char) (phys_port + 'A'));
					printf("PIN_%s  equ %u\n\n",   appname, phys_pin);
					break;

				case PIN_TYPE_UNUSED:
				case PIN_TYPE_VGND:
					break;
			}
		}
	}

	/* Generate the bootup macro. */
	puts("PINS_INITIALIZE macro");
	for (phys_port = 0; phys_port < 5; ++phys_port) {
		lat = tris = 0;
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_UNUSED:
					tris |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT1:
					lat |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT0:
				case PIN_TYPE_VGND:
					break;
			}
		}
		if (lat) {
			printf("\tmovlw 0x%02X\n", lat);
			printf("\tmovwf LAT%c\n", (char) (phys_port + 'A'));
		} else {
			printf("\tclrf LAT%c\n", (char) (phys_port + 'A'));
		}
		if (tris) {
			printf("\tmovlw 0x%02X\n", tris);
			printf("\tmovwf TRIS%c\n", (char) (phys_port + 'A'));
		} else {
			printf("\tclrf TRIS%c\n", (char) (phys_port + 'A'));
		}
	}
	puts("\tendm");
	puts("");

	/* Generate the footer. */
	puts("\tendif");

	return 0;
}

