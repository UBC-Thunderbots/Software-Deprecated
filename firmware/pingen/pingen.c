#include <ctype.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

enum pin_type {
	PIN_TYPE_UNUSED = 0,
	PIN_TYPE_IN,
	PIN_TYPE_OUT0,
	PIN_TYPE_OUT1,
	PIN_TYPE_VGND,
	PIN_TYPE_VVDD
};

struct pin_info {
	char appname[32];
	enum pin_type type;
};

struct port_info {
	struct pin_info pins[8];
};

static char *strip(char *str) {
	char *p;

	/* Remove comment, if any. */
	p = strchr(str, '#');
	if (p) {
		*p = '\0';
	}

	/* Remove trailing whitespace. */
	p = str + strlen(str);
	while (p > str && isspace(p[-1])) {
		*--p = '\0';
	}

	/* Remove leading whitespace. */
	p = str;
	while (isspace(*p)) {
		++p;
	}

	return p;
}

static int split(char *line, char **appname, char **physname, char **type) {
	*appname = strtok(line, " \t");
	if (!*appname) return 0;
	*physname = strtok(0, " \t");
	if (!*physname) return 0;
	*type = strtok(0, " \t");
	if (!*type) return 0;
	if (strtok(0, " \t")) return 0;
	return 1;
}

static int extract_phys(const char *phys, unsigned int *phys_port, unsigned int *phys_pin) {
	if (strlen(phys) != 3) return 0;
	if (phys[0] != 'R') return 0;
	if (phys[1] < 'A' || phys[1] > 'G') return 0;
	*phys_port = phys[1] - 'A';
	if (phys[2] < '0' || phys[2] > '7') return 0;
	*phys_pin = phys[2] - '0';
	return 1;
}

static int extract_type(const char *typename, enum pin_type *type) {
	if (strcmp(typename, "in") == 0) { *type = PIN_TYPE_IN; return 1; }
	else if (strcmp(typename, "out0") == 0) { *type = PIN_TYPE_OUT0; return 1; }
	else if (strcmp(typename, "out1") == 0) { *type = PIN_TYPE_OUT1; return 1; }
	else if (strcmp(typename, "vgnd") == 0) { *type = PIN_TYPE_VGND; return 1; }
	else if (strcmp(typename, "vvdd") == 0) { *type = PIN_TYPE_VVDD; return 1; }
	else return 0;
}

int main(int argc, char **argv) {
	FILE *f;
	unsigned int line_num = 0;
	char line[4096];
	char *stripped;
	char *appname, *physname, *typename;
	unsigned int phys_port, phys_pin, lat, tris;
	enum pin_type type;
	struct port_info ports[7];

	/* Check arguments. */
	if (argc != 2) {
		fprintf(stderr, "Usage:\n%s pindb\n", argv[0]);
		return 1;
	}

	/* Open input file. */
	if (!(f = fopen(argv[1], "r"))) {
		perror("fopen");
		return 1;
	}

	/* Clear the port list. */
	memset(ports, 0, sizeof(ports));

	/* Read and parse the input. */
	while (fgets(line, sizeof(line), f)) {
		++line_num;
		stripped = strip(line);
		if (!*stripped) {
			continue;
		}
		if (!split(stripped, &appname, &physname, &typename)) {
			fprintf(stderr, "Parse error on line %u.\n", line_num);
			return 1;
		}

		if (strlen(appname) >= 32) {
			fprintf(stderr, "Syntax error on line %u: app name must be < 32 characters.\n", line_num);
			return 1;
		}

		if (!extract_phys(physname, &phys_port, &phys_pin)) {
			fprintf(stderr, "Syntax error on line %u: phys name must be Rxy, where x in {A,B,C,D,E,F,G} and y in {0..7}.\n", line_num);
			return 1;
		}

		if (!extract_type(typename, &type)) {
			fprintf(stderr, "Syntax error on line %u: type must be one of {in, out0, out1, vgnd}.\n", line_num);
			return 1;
		}

		if (ports[phys_port].pins[phys_pin].type != PIN_TYPE_UNUSED) {
			fprintf(stderr, "Semantic error on line %u: physical pin %s already used by application pin %s.\n", line_num, physname, ports[phys_port].pins[phys_pin].appname);
			return 1;
		}

		ports[phys_port].pins[phys_pin].type = type;
		strcpy(ports[phys_port].pins[phys_pin].appname, appname);
	}

	/* Open the assembly output file. */
	if (!freopen("pins.inc", "w", f)) {
		perror("freopen");
		return 1;
	}

	/* Generate the header.. */
	fputs("\t; asmsyntax=pic\n", f);
	fputc('\n', f);
	fputs("\t; This file is automatically generated. Do not edit it.\n", f);
	fputc('\n', f);
	fputs("\tifndef PINS_INC_INCLUDED\n", f);
	fputs("#define PINS_INC_INCLUDED 1\n", f);
	fputc('\n', f);

	/* Generate the port name equates. */
	for (phys_port = 0; phys_port < sizeof(ports) / sizeof(*ports); ++phys_port) {
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			appname = ports[phys_port].pins[phys_pin].appname;
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_OUT0:
				case PIN_TYPE_OUT1:
					fprintf(f, "PORT_%s equ PORT%c\n", appname, (char) (phys_port + 'A'));
					fprintf(f, "TRIS_%s equ TRIS%c\n", appname, (char) (phys_port + 'A'));
					fprintf(f, "LAT_%s  equ LAT%c\n",  appname, (char) (phys_port + 'A'));
					fprintf(f, "PIN_%s  equ %u\n\n",   appname, phys_pin);
					break;

				case PIN_TYPE_UNUSED:
				case PIN_TYPE_VGND:
				case PIN_TYPE_VVDD:
					break;
			}
		}
	}

	/* Generate the bootup macro. */
	fputs("PINS_INITIALIZE macro\n", f);
	for (phys_port = 0; phys_port < sizeof(ports) / sizeof(*ports); ++phys_port) {
		lat = tris = 0;
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_UNUSED:
					tris |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT1:
				case PIN_TYPE_VVDD:
					lat |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT0:
				case PIN_TYPE_VGND:
					break;
			}
		}
		if (lat) {
			fprintf(f, "\tmovlw 0x%02X\n", lat);
			fprintf(f, "\tmovwf LAT%c\n", (char) (phys_port + 'A'));
		} else {
			fprintf(f, "\tclrf LAT%c\n", (char) (phys_port + 'A'));
		}
		if (tris) {
			fprintf(f, "\tmovlw 0x%02X\n", tris);
			fprintf(f, "\tmovwf TRIS%c\n", (char) (phys_port + 'A'));
		} else {
			fprintf(f, "\tclrf TRIS%c\n", (char) (phys_port + 'A'));
		}
	}
	fputs("\tendm\n", f);
	fputc('\n', f);

	/* Generate the footer. */
	fputs("\tendif\n", f);

	/* Open the C output file. */
	if (!freopen("pins.h", "w", f)) {
		perror("freopen");
		return 1;
	}

	/* Generate the header.. */
	fputs("#ifndef PINS_H\n", f);
	fputs("#define PINS_H\n", f);
	fputc('\n', f);
	fputs("/* This file is automatically generated. Do not edit it. */\n", f);
	fputc('\n', f);

	/* Generate the port name macros. */
	for (phys_port = 0; phys_port < sizeof(ports) / sizeof(*ports); ++phys_port) {
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			appname = ports[phys_port].pins[phys_pin].appname;
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_OUT0:
				case PIN_TYPE_OUT1:
					fprintf(f, "#define TRIS_%s (TRIS%cbits.TRIS%c%u)\n", appname, (char) (phys_port + 'A'), (char) (phys_port + 'A'), phys_pin);
					fprintf(f, "#define PORT_%s (PORT%cbits.R%c%u)\n", appname, (char) (phys_port + 'A'), (char) (phys_port + 'A'), phys_pin);
					fprintf(f, "#define LAT_%s (LAT%cbits.LAT%c%u)\n", appname, (char) (phys_port + 'A'), (char) (phys_port + 'A'), phys_pin);
					break;

				case PIN_TYPE_UNUSED:
				case PIN_TYPE_VGND:
				case PIN_TYPE_VVDD:
					break;
			}
		}
	}

	/* Generate the bootup macro. */
	fputs("#define PINS_INITIALIZE() \\\n", f);
	fputs("\tdo { \\\n", f);
	for (phys_port = 0; phys_port < sizeof(ports) / sizeof(*ports); ++phys_port) {
		lat = tris = 0;
		for (phys_pin = 0; phys_pin < 8; ++phys_pin) {
			type = ports[phys_port].pins[phys_pin].type;
			switch (type) {
				case PIN_TYPE_IN:
				case PIN_TYPE_UNUSED:
					tris |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT1:
				case PIN_TYPE_VVDD:
					lat |= 1 << phys_pin;
					break;

				case PIN_TYPE_OUT0:
				case PIN_TYPE_VGND:
					break;
			}
		}
		fprintf(f, "\t\t LAT%c = 0x%02X; \\\n", (char) (phys_port + 'A'), lat);
		fprintf(f, "\t\tTRIS%c = 0x%02X; \\\n", (char) (phys_port + 'A'), tris);
	}
	fputs("\t} while (0)\n", f);
	fputc('\n', f);

	/* Generate the footer. */
	fputs("#endif\n\n", f);

	/* Close the output file. */
	fclose(f);

	return 0;
}

