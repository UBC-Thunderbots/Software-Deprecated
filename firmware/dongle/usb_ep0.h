#ifndef USB_EP0_H
#define USB_EP0_H

/**
 * \file
 *
 * \brief Provides functionality related to USB endpoint zero
 */

#include "stdbool.h"
#include "stddef.h"
#include "stdint.h"



/**
 * \name USB standard identifiers
 *
 * These names represent ID numbers used in the USB standard.
 *
 * @{
 */

/**
 * \brief The request type bit fields
 */
enum {
	USB_STD_REQ_TYPE_OUT = 0x00,
	USB_STD_REQ_TYPE_IN = 0x80,
	USB_STD_REQ_TYPE_STD = 0x00,
	USB_STD_REQ_TYPE_CLASS = 0x20,
	USB_STD_REQ_TYPE_VENDOR = 0x40,
	USB_STD_REQ_TYPE_DEVICE = 0x00,
	USB_STD_REQ_TYPE_INTERFACE = 0x01,
	USB_STD_REQ_TYPE_ENDPOINT = 0x02,
};

/**
 * \brief The standard request codes
 */
enum {
	USB_STD_REQ_GET_STATUS = 0,
	USB_STD_REQ_CLEAR_FEATURE = 1,
	USB_STD_REQ_SET_FEATURE = 3,
	USB_STD_REQ_SET_ADDRESS = 5,
	USB_STD_REQ_GET_DESCRIPTOR = 6,
	USB_STD_REQ_SET_DESCRIPTOR = 7,
	USB_STD_REQ_GET_CONFIGURATION = 8,
	USB_STD_REQ_SET_CONFIGURATION = 9,
	USB_STD_REQ_GET_INTERFACE = 10,
	USB_STD_REQ_SET_INTERFACE = 11,
	USB_STD_REQ_SYNCH_FRAME = 12,
};

/**
 * \brief The standard descriptor types
 */
enum {
	USB_STD_DESCRIPTOR_DEVICE = 1,
	USB_STD_DESCRIPTOR_CONFIGURATION = 2,
	USB_STD_DESCRIPTOR_STRING = 3,
	USB_STD_DESCRIPTOR_INTERFACE = 4,
	USB_STD_DESCRIPTOR_ENDPOINT = 5,
	USB_STD_DESCRIPTOR_DEVICE_QUALIFIER = 6,
	USB_STD_DESCRIPTOR_OTHER_SPEED_CONFIGURATION = 7,
	USB_STD_DESCRIPTOR_INTERFACE_POWER = 8,
};

/**
 * \brief The standard features
 */
enum {
	USB_STD_FEATURE_ENDPOINT_HALT = 0,
	USB_STD_FEATURE_DEVICE_REMOTE_WAKEUP = 1,
	USB_STD_FEATURE_TEST_MODE = 2,
};

/**
 * @}
 */



/**
 * \name Callback management
 *
 * These types and functions handle registering callbacks with the stack to be invoked when certain events occur.
 *
 * @{
 */

/**
 * \brief A source of data to be sent in a control transfer
 */
typedef struct {
	/**
	 * \brief Private data usable by the implementation of the data source
	 */
	void *opaque;

	/**
	 * \brief Generates some data
	 *
	 * This callback is mandatory.
	 *
	 * For optimization: note that \p length will always be a multiple of 8 except if one of the following conditions is true:
	 * \li the framework guarantees it will never call the generator again with more buffer space (this happens as the generator nears the end of the amount of data requested by the host), OR
	 * \li the generator previously returned a block of data that was not a multiple of 8 bytes
	 *
	 * This implies that a generator whose natural operation is to generate a block of bytes at a time that is a power of two no more than eight need not arrange to buffer a partially-consumed block.
	 *
	 * For additional convenience, the framework guarantees that even if the host requests a shorter amount of data, the buffer is a multiple of four bytes in length, so the generator may write past the end \em if it only ever generates appropriate numbers of bytes at a time that the pointer cannot become unaligned.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre \p length is nonzero.
	 *
	 * \post \p buffer[0] through \p buffer[N-1] have been populated, if \code N is the return value.
	 *
	 * \param[in] opaque the opaque pointer from the data source structure
	 *
	 * \param[out] buffer the location in which to store generated bytes
	 *
	 * \param[in] length the maximum number of bytes to generate
	 *
	 * \return the number of bytes generated, which may be anything up to \p length but which may only be zero at the end of the data
	 */
	size_t (*generate)(void *opaque, void *buffer, size_t length);
} usb_ep0_source_t;

/**
 * \brief A set of callbacks to handle device-wide activities
 */
typedef struct {
	/**
	 * \brief Allows the application to override handling of any control request with no data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *accept must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[out] accept \c true to accept the request, or \c false to return a STALL handshake
	 *
	 * \return \c true if the application handles the request and demands a response per the \p accept parameter, or \c false to let the stack handle the request
	 */
	bool (*on_zero_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, bool *accept);

	/**
	 * \brief Allows the application to override handling of any control request with an IN data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *source must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[in] length the length of the data stage as specified by the host
	 *
	 * \param[out] source set to a source by the application to accept the request and return the sourced data, or to null to stall the request
	 *
	 * \return \c true if the application handles the request and demands a response per the \p source parameter, or \c false to let the stack handle the request
	 */
	bool (*on_in_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, uint16_t length, usb_ep0_source_t **source);

	/**
	 * \brief Allows the application to override handling of any control request with an OUT data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *dest and \p *cb must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[in] length the length of the data stage as specified by the host
	 *
	 * \param[out] dest set to a target buffer by the application to accept the request, or to null to stall the request
	 *
	 * \param[out] cb set to a callback by the application if it must be notified after the data stage completes to consume the data;
	 * the callback may return \c true to issue a successful status stage, or \c false to stall the status stage
	 *
	 * \return \c true if the application handles the request and demands a response per the \p dest parameter, or \c false to let the stack handle the request
	 */
	bool (*on_out_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, uint16_t length, void **dest, bool (**cb)(void));

	/**
	 * \brief Handles a request for a descriptor
	 *
	 * This function will be invoked for string descriptor zero, but never for a nonzero string descriptor.
	 *
	 * This callback is mandatory.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *data and \p *length must be set to appropriate values, or the callback must return \c false.
	 *
	 * \param[in] descriptor_type the type of descriptor being requested.
	 *
	 * \param[in] descriptor_index the index of the descriptor being requested.
	 *
	 * \param[in] language the language of the descriptor being requested, or zero for non-string descriptors
	 *
	 * \param[out] data a pointer to the requested descriptor.
	 *
	 * \param[out] length the total number of bytes to include in the descriptor as sent to the host.
	 *
	 * \return \c true if the request is acceptable, or \c false if the requested descriptor does not exist
	 */
	usb_ep0_source_t *(*on_descriptor_request)(uint8_t descriptor_type, uint8_t descriptor_index, uint16_t language);

	/**
	 * \brief Checks whether the device is self-powered
	 *
	 * A self-powered device has its own power supply; a bus-powered device is powered by the USB.
	 *
	 * This callback is mandatory.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \return \c true if the device is self-powered at this moment, or \c false if bus-powered
	 */
	bool (*on_check_self_powered)(void);
} usb_ep0_global_callbacks_t;

/**
 * \brief Sets the global endpoint 0 callbacks the application uses to be informed of global events
 *
 * \param[in] callbacks the callbacks to register.
 */
void usb_ep0_set_global_callbacks(const usb_ep0_global_callbacks_t *callbacks);

/**
 * \brief A set of callbacks to handle activities related to a single configuration
 */
typedef struct {
	/**
	 * \brief The configuration value of the configuration
	 */
	uint8_t configuration;

	/**
	 * \brief The number of interfaces in this configuration
	 */
	uint8_t interfaces;

	/**
	 * \brief The number of (non-zero) OUT endpoints in this configuration
	 */
	uint8_t out_endpoints;

	/**
	 * \brief The number of (non-zero) IN endpoints in this configuration
	 */
	uint8_t in_endpoints;

	/**
	 * \brief Checks whether it's acceptable to enter this configuration at this time
	 *
	 * This callback is optional; if not provided, requests to enter the configuration always succeed.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \return \c true if the request is acceptable, or \c false if not
	 */
	bool (*can_enter)(void);

	/**
	 * \brief Enters the configuration
	 *
	 * This callback is optional.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 */
	void (*on_enter)(void);

	/**
	 * \brief Exits the configuration
	 *
	 * This callback is optional.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 */
	void (*on_exit)(void);

	/**
	 * \brief Allows the application to override handling of any control request with no data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * This callback is executed before, and can override, any corresponding device-wide callback.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *accept must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[out] accept \c true to accept the request, or \c false to return a STALL handshake
	 *
	 * \return \c true if the application handles the request and demands a response per the \p accept parameter, or \c false to let the stack handle the request
	 */
	bool (*on_zero_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, bool *accept);

	/**
	 * \brief Allows the application to override handling of any control request with an IN data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * This callback is executed before, and can override, any corresponding device-wide callback.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *source must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[in] length the length of the data stage as specified by the host
	 *
	 * \param[out] source set to a source by the application to accept the request and return the sourced data, or to null to stall the request
	 *
	 * \return \c true if the application handles the request and demands a response per the \p source parameter, or \c false to let the stack handle the request
	 */
	bool (*on_in_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, uint16_t length, usb_ep0_source_t **source);

	/**
	 * \brief Allows the application to override handling of any control request with an OUT data stage
	 *
	 * This callback is optional; if not provided, it is treated as though always returning \c false.
	 *
	 * This callback is executed before, and can override, any corresponding device-wide callback.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre Global NAK is effective in both directions.
	 *
	 * \post Either \p *dest and \p *cb must be set to an appropriate value, or the callback must return \c false.
	 *
	 * \param[in] request_type the request type field from the SETUP transaction
	 *
	 * \param[in] request the request field from the SETUP transaction
	 *
	 * \param[in] value the value field from the SETUP transaction
	 *
	 * \param[in] index the index field from the SETUP transaction
	 *
	 * \param[in] length the length of the data stage as specified by the host
	 *
	 * \param[out] dest set to a target buffer by the application to accept the request, or to null to stall the request
	 *
	 * \param[out] cb set to a callback by the application if it must be notified after the data stage completes to consume the data;
	 * the callback may return \c true to issue a successful status stage, or \c false to stall the status stage
	 *
	 * \return \c true if the application handles the request and demands a response per the \p dest parameter, or \c false to let the stack handle the request
	 */
	bool (*on_out_request)(uint8_t request_type, uint8_t request, uint16_t value, uint16_t index, uint16_t length, void **dest, bool (**cb)(void));
} usb_ep0_configuration_callbacks_t;

/**
 * \brief Sets the configuration callbacks the application uses for all configurations
 *
 * \param[in] configurations an array of pointers to configuration callback structures, one per configuration, ending with a null pointer
 */
void usb_ep0_set_configuration_callbacks(const usb_ep0_configuration_callbacks_t * const *configurations);

/**
 * @}
 */



/**
 * \name Miscellaneous
 *
 * @{
 */

/**
 * \brief Checks which configuration is currently active
 *
 * \return the current configuration number, which may be 0 if the device is unconfigured
 */
uint8_t usb_ep0_get_configuration(void);

/**
 * @}
 */

#endif

