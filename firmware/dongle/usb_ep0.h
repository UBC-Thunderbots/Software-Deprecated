#ifndef USB_EP0_H
#define USB_EP0_H

/**
 * \file
 *
 * \brief Provides functionality related to USB endpoint zero
 */

#include "stdbool.h"
#include "stddef.h"
#include "stdint.h"



/**
 * \name USB standard identifiers
 *
 * These names represent ID numbers used in the USB standard.
 *
 * @{
 */

/**
 * \brief The standard request codes
 */
enum {
	USB_STD_REQ_GET_STATUS = 0,
	USB_STD_REQ_CLEAR_FEATURE = 1,
	USB_STD_REQ_SET_FEATURE = 3,
	USB_STD_REQ_SET_ADDRESS = 5,
	USB_STD_REQ_GET_DESCRIPTOR = 6,
	USB_STD_REQ_SET_DESCRIPTOR = 7,
	USB_STD_REQ_GET_CONFIGURATION = 8,
	USB_STD_REQ_SET_CONFIGURATION = 9,
	USB_STD_REQ_GET_INTERFACE = 10,
	USB_STD_REQ_SET_INTERFACE = 11,
	USB_STD_REQ_SYNCH_FRAME = 12,
};

/**
 * \brief The standard descriptor types
 */
enum {
	USB_STD_DESCRIPTOR_DEVICE = 1,
	USB_STD_DESCRIPTOR_CONFIGURATION = 2,
	USB_STD_DESCRIPTOR_STRING = 3,
	USB_STD_DESCRIPTOR_INTERFACE = 4,
	USB_STD_DESCRIPTOR_ENDPOINT = 5,
	USB_STD_DESCRIPTOR_DEVICE_QUALIFIER = 6,
	USB_STD_DESCRIPTOR_OTHER_SPEED_CONFIGURATION = 7,
	USB_STD_DESCRIPTOR_INTERFACE_POWER = 8,
};

/**
 * \brief The standard features
 */
enum {
	USB_STD_FEATURE_ENDPOINT_HALT = 0,
	USB_STD_FEATURE_DEVICE_REMOTE_WAKEUP = 1,
	USB_STD_FEATURE_TEST_MODE = 2,
};

/**
 * @}
 */



/**
 * \name Callback management
 *
 * These types and functions handle registering callbacks with the stack to be invoked when certain events occur.
 *
 * @{
 */

/**
 * \brief A source of data to be sent in a control transfer
 */
typedef struct {
	/**
	 * \brief Private data usable by the implementation of the data source
	 */
	void *opaque;

	/**
	 * \brief Generates some data
	 *
	 * This callback is mandatory.
	 *
	 * For optimization: note that \p length will always be a multiple of 8 except if one of the following conditions is true:
	 * \li the framework guarantees it will never call the generator again with more buffer space (this happens as the generator nears the end of the amount of data requested by the host), OR
	 * \li the generator previously returned a block of data that was not a multiple of 8 bytes
	 *
	 * This implies that a generator whose natural operation is to generate a block of bytes at a time that is a power of two no more than eight need not arrange to buffer a partially-consumed block.
	 *
	 * For additional convenience, the framework guarantees that even if the host requests a shorter amount of data, the buffer is a multiple of four bytes in length, so the generator may write past the end \em if it only ever generates appropriate numbers of bytes at a time that the pointer cannot become unaligned.
	 *
	 * \pre Callback context is executing.
	 *
	 * \pre \p length is nonzero.
	 *
	 * \post \p buffer[0] through \p buffer[N-1] have been populated, if \code N is the return value.
	 *
	 * \param[in] opaque the opaque pointer from the data source structure
	 *
	 * \param[out] buffer the location in which to store generated bytes
	 *
	 * \param[in] length the maximum number of bytes to generate
	 *
	 * \return the number of bytes generated, which may be anything up to \p length but which may only be zero at the end of the data
	 */
	size_t (*generate)(void *opaque, void *buffer, size_t length);
} usb_ep0_source_t;

/**
 * \brief A set of callbacks to handle device-wide activities
 */
typedef struct {
	/**
	 * \brief Handles a request for a descriptor
	 *
	 * This function will be invoked for string descriptor zero, but never for a nonzero string descriptor.
	 *
	 * This callback is mandatory.
	 *
	 * \pre Callback context is executing.
	 *
	 * \post Either \p *data and \p *length must be set to appropriate values, or the callback must return \c false.
	 *
	 * \param[in] descriptor_type the type of descriptor being requested.
	 *
	 * \param[in] descriptor_index the index of the descriptor being requested.
	 *
	 * \param[out] data a pointer to the requested descriptor.
	 *
	 * \param[out] length the total number of bytes to include in the descriptor as sent to the host.
	 *
	 * \return \c true if the request is acceptable, or \c false if the requested descriptor does not exist
	 */
#if 0
	bool (*on_descriptor_request)(uint8_t descriptor_type, uint8_t descriptor_index, const void **data, size_t *length);
#else
	usb_ep0_source_t *(*on_descriptor_request)(uint8_t descriptor_type, uint8_t descriptor_index);
#endif
} usb_ep0_global_callbacks_t;

/**
 * \brief Sets the global endpoint 0 callbacks the application uses to be informed of global events
 *
 * \param[in] callbacks the callbacks to register.
 */
void usb_ep0_set_global_callbacks(const usb_ep0_global_callbacks_t *callbacks);

/**
 * \brief A set of callbacks to handle activities related to a single configuration
 */
typedef struct {
	/**
	 * \brief The configuration value of the configuration
	 */
	uint8_t configuration;

	/**
	 * \brief Checks whether it's acceptable to enter this configuration at this time
	 *
	 * This callback is optional; if not provided, requests to enter the configuration always succeed.
	 *
	 * \return \c true if the request is acceptable, or \c false if not
	 */
	bool (*can_enter)(void);

	/**
	 * \brief Enters the configuration
	 *
	 * This callback is optional.
	 */
	void (*on_enter)(void);

	/**
	 * \brief Exits the configuration
	 *
	 * This callback is optional.
	 */
	void (*on_exit)(void);

#warning we need a way to do things like alt settings and endpoint halt reporting
} usb_ep0_configuration_callbacks_t;

/**
 * \brief Sets the configuration callbacks the application uses for all configurations
 *
 * \param[in] configurations an array of configuration callback structures, one per configuration
 *
 * \param[in] length the number of structures in the array
 */
void usb_ep0_set_configuration_callbacks(const usb_ep0_configuration_callbacks_t *configurations, size_t length);

/**
 * @}
 */

#endif

